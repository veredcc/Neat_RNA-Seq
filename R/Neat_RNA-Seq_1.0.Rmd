---
title: "Analysis of RNA-Seq data using DESeq2 and additional packages"
author: "Vered Chalifa-Caspi"
date: "14.4.2020"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
	keep_md: true

---

# About

The script is a modification and extension by Vered Chalifa-Caspi of an original script written by Menachem Sklarz (menachem.sklarz@gmail.com)
Some of the code was adopted from the DeSeq2 module (https://github.com/bioinfo-core-BGU/neatseq-flow-modules/tree/master/neatseq_flow_modules/Liron/DeSeq2_module) by Liron Levin (levinl@bgu.ac.il)

Before execution of the code, make sure to update the "Global_paramters.Rmd" file to fit your current project.

The code is meant to run chunk by chunk, using only chunks that are relevant to the current analysis.


# Load libraries and source R code

```{r setup, include=FALSE}
library(dplyr)
library(tibble)
library(tidyr)
library(tidyverse)
library(magrittr) 
library(RColorBrewer)
library(pheatmap)
library(gridExtra)
library(openxlsx)
library(plotly)
library(colorspace)
library(ggrepel)
library(htmlwidgets)
library(factoextra) 
library(cowplot)
library(ggplot2)

library(DESeq2)
library(tximport)
library(BiocParallel)
library(clusterProfiler)
library(KEGGREST)
library(sva)
library(scater)
library(enrichplot)

library(DOSE)

source ("Global_parameters_adipose.R")
source ("Functions_for_Neat_RNA-Seq_1.0.R")

```
# Preparations

```{r preparations}

analysis_name = paste0 (project_name, "_", analysis_round)

LOG_FC_CUTOFF = log(LINEAR_FC_CUTOFF)

#create manual cutoff formula for excel
manual_cutoff_formula = 'IF(AND(ISNUMBER(indirect(ADDRESS(ROW(),COLUMN()-2))),indirect(ADDRESS(ROW(),COLUMN()-2))<=FDR_CO,indirect(ADDRESS(ROW(),COLUMN()-3))<=PVAL_CO,ABS(indirect(ADDRESS(ROW(),COLUMN()-4)))>=LFC_CO),IF(indirect(ADDRESS(ROW(),COLUMN()-4))>0,"up","down"),"")'

```

# Out files

```{r outfiles}

# create results directory if it does not exist
results_dir = paste0("Results_", analysis_name) %>% create_dir

# create sub-directories within the results directory, if they do not yet exist
plots_dir               = file.path(results_dir, "Diagnostic_plots") %>% create_dir  #for diagnostic plots
clustering_dir          = file.path(results_dir, "Clustering")       %>% create_dir
enrich_results_main_dir = file.path(results_dir, "Enrichment")       %>% create_dir
GSEA_results_main_dir   = file.path(results_dir, "GSEA_enrichment")  %>% create_dir

#define files
norm_log_counts_file           = sprintf("%s/%s_%s.txt",                   results_dir,NORM_METHOD, analysis_name)
batch_corr_file                = sprintf("%s/Batch_corr_%s_%s_%s.txt",     results_dir,BATCH_CORR_METHOD, NORM_METHOD, analysis_name)
DE_genes_stats_file            = sprintf("%s/summary_DE_stats_%s.txt",     results_dir,analysis_name)

current_date = format(Sys.Date(), "%d.%m.%y")
final_results_file             = sprintf("%s/RESULTS_%s_%s.xlsx",          results_dir,analysis_name, current_date)
final_results_ALL_file         = sprintf("%s/RESULTS_ALL_%s_%s.xlsx",      results_dir,analysis_name, current_date)
final_results_DE_file          = sprintf("%s/RESULTS_DE_%s_%s.xlsx",       results_dir,analysis_name, current_date)
final_results_Interaction_file = sprintf("%s/RESULTS_INTERACT_%s_%s.xlsx", results_dir,analysis_name, current_date)
final_results_Combined_file    = sprintf("%s/RESULTS_COMBINED_%s_%s.xlsx", results_dir,analysis_name, current_date)

```
# Gene Annotation

## External (e.g. from Ensembl)
(from external file)

```{r process external annot}
if (USE_EXTERNAL_ANNOTATION) {
  annot = process_annotation_data (annotation_file, ANNOT_SOURCE)
}

```

## Trinotate

```{r trinotate}
if (USE_TRINOTATE_ANNOTATION) {
  trinotate_main = process_trinotate_data (trinotate_file)
}

```
# Statistics - Part I

## Import RSEM counts data

```{r tximport}
txi.rsem = import_rsem (rsem_files_locations, CHOP_GENE_ID_BY_DELIMITER, GENE_ID_DELIMITER)

```

## Prepare column data

```{r arrange_coldata}
col_data = prepare_col_data (experiment_design_file)
col_data

```

## OPTIONAL: Create sample subset

```{r filter_coldata}

#remove outlier samples from col_data:

outlier_samples = c("X12.Eye_Immat", "X21.Eye_Female")

col_data = remove_samples_from_coldata(col_data, outlier_samples)

#filter col_data to include only a specific tissue

col_attribute = "Body_part"   #name of a column in the experiment design file
tissue = "Eye"                #a certain value (factor) in that column

col_data = filter_coldata_by_tissue (col_data, col_attribute, tissue)

```

## Subset, reorder and check data

```{r subset_and_reorder}

#Subset and reorder txi.rsem according to col_data, then check that they match

txi.rsem = match_txi_rsem_to_coldata (txi.rsem, col_data)

```

## Run DESeq2

```{r sex_by_tissue}

txi.rsem$length[txi.rsem$length < 1] <- 1  #added due to error "Error in DESeqDataSetFromTximport(txi = txi.rsem, colData = col_data,  : all(lengths > 0) is not TRUE" (see https://support.bioconductor.org/p/92763/)

cat ("Running DESeq 2 - regular\n")

dds = run_deseq2 (txi.rsem, col_data, DESIGN, use_expanded_model) #use_expanded_model can be true or false. see top of script

if (CALC_INTERACTION) {
  cat ("Running DESeq2 for interaction\n")
  dds_interaction = run_deseq2_interaction (txi.rsem, col_data, DESIGN_INTERACTION, LRT, use_expanded_model)  #use LRT (for interaction)
}

```

## Create normalized counts

```{r save_norm_counts}

norm_counts <- counts(dds,normalized=TRUE)

if (NORM_METHOD == 'VSD') {
  vsd <- varianceStabilizingTransformation(dds,blind=TRUE)
  norm_log_counts = assay(vsd)
} else if (NORM_METHOD == 'RLOG') {
  rlog_counts <- rlog(dds, blind=TRUE)
  norm_log_counts = assay(rlog_counts)
}

export_table (norm_log_counts, norm_log_counts_file)

```
## Batch correction

```{r batch correction}

if (REMOVE_BATCH_EFFECT){
  
  orig_norm_log_counts = norm_log_counts  #just to save also the norm counts before batch correction

  if (BATCH_CORR_METHOD =="sva"){
    if (length(BATCH_EFFECTS)>1){
      print ("It is Not possible to use more than one batch effect using the sva package, will use only the first one!!")
    }
    DESIGN_list = unlist(stringi::stri_split( stringi::stri_replace(str = DESIGN,
                                                                    regex =' |~',
                                                                    mode = 'all',
                                                                    replacement = ''),
                                              fixed = '+'))
    New_DESIGN =paste0('~',paste(DESIGN_list[DESIGN_list!=BATCH_EFFECTS[1]],collapse ='+'))
    
    
    
    modcombat = model.matrix( as.formula(New_DESIGN) , data=col_data)
    combat_edata = ComBat(dat = norm_log_counts,
                             batch = col_data[,BATCH_EFFECTS[1]],
                             mod = modcombat,
                             par.prior = T,
                             mean.only=F)

    norm_log_counts = combat_edata
 
  }else if (BATCH_CORR_METHOD == 'limma') {
    
    if (length(BATCH_EFFECTS)>1){
      limma_edata = limma::removeBatchEffect(norm_log_counts,
                                                 batch = col_data[,BATCH_EFFECTS[1]],
                                                 batch2= col_data[,BATCH_EFFECTS[2]])
    }else{
      limma_edata = limma::removeBatchEffect(norm_log_counts,
                                                 batch = col_data[,BATCH_EFFECTS[1]])
      norm_log_counts = limma_edata
    }
  }
  
  export_table (norm_log_counts, batch_corr_file)
}

```

#Visualization - Counts data

## Sample correlation matrix

```{r sample_dist_heatmap}

draw_sample_correlation_matrix (norm_log_counts, plots_dir)

```

## PCA

```{r sample_dist_heatmap}
norm_log_counts_pca  = draw_pca (norm_log_counts, plots_dir, 1, 2, shape=EFFECTS[1], color=EFFECTS[2])  #draw PCA 1, 2
norm_log_counts_pca1 = draw_pca (norm_log_counts, plots_dir, 1, 3, shape=EFFECTS[1], color=EFFECTS[2])  #draw PCA 1, 3

pca_3d_file = paste("PCA_3D_", analysis_name, ".html", sep="")  #for some reason. it can't print the 3D PCA to a subdirectory
draw_pca_3d (norm_log_counts_pca, pca_3d_file, shape=EFFECTS[1], color=EFFECTS[2]) #draw 3D PCA
 
```
# Statistics - Part II

## Compute contrasts

```{r results_df_stats}

contrasts_data = NA				   
if (CALC_CONTRASTS) {
  
  #read required contrasts from file
  contrasts_data = read.delim(contrasts_file,
                              header           = T,
                              stringsAsFactors = F)
  
  stats_df = compute_contrasts (dds, contrasts_data)
}

```

## Compute interaction

```{r results_df_stats}

if (CALC_INTERACTION) {
  stats_df_interaction = compute_interaction (dds_interaction)
}

```

## Combine contrasts and interaction

```{r results_df_stats}

# Combine stats df of contrasts and interaction and add "pass_any_or_interaction"

if (CALC_CONTRASTS && CALC_INTERACTION) {
  stats_df_combined = combine_stat_dfs(stats_df, stats_df_interaction)

}

```

## Summary statistics on passed genes

```{r pass_stats}

if (CALC_CONTRASTS) {
  DE_genes_stats = de_summary_stats (stats_df, DE_genes_stats_file)
  DE_genes_stats
}

if (CALC_INTERACTION) {
  cat ("No. of genes with significant interaction: ", sum(stats_df_interaction$pass.interaction=="interaction"))
  cat ("\n")
}
if (CALC_CONTRASTS && CALC_INTERACTION) {
  cat ("No. of DE genes in any contrast or with significant interaction: ", sum(stats_df_combined$pass_combined=="1"))
  cat ("\n")
}

```
## Create lists of DE genes

``` {r DE_genes_lists}

#Initialize a list that will contain all types of gene lists, from contrasts, from clustering with different methods, etc.
#The list has two levels, e.g. "contrasts" points to each contrast, and each contrast points to a "clusters" object,
#and each type of clustering method can point to several instances each used different parameters for the clustering
#The contrasts object is a named vector with genes as names and values as cluster name (or number)
gene_lists = list()  #this list will contain all types of gene lists, from contrasts, from clustering etc.

#add contrasts "clusters"
for (contrast in contrasts_data$Contrast_name) {
  #create a clusters object per contrast, considering two clusters: "up" and "down"
  clusters =  get_DE_genes_list_per_contrast (contrast, stats_df)
  gene_lists[["contrasts"]][[contrast]] = clusters
  #create a clusters object per contrast, merging the up and down genes to one cluster called "all"
  clusters_wo_direction = setNames(rep("all", length(clusters)), names(clusters))
  gene_lists[["contrasts_wo_direction"]][[contrast]] = clusters_wo_direction
}

```

#Visualization - Contrasts data

## MA and volcano plots

```{r MA_plots}

if (CALC_CONTRASTS) {
  draw_ma_and_volcano_plots (dds, contrasts_data, plots_dir)
}

```

# Filter genes

## Based on statistics

```{r filter_genes}

#get all DE genes

if (CALC_CONTRASTS) {
  DE_genes = get_DE_genes_list (stats_df)
} 
if (CALC_INTERACTION) {
  DE_genes_interaction = get_DE_genes_list_interaction (stats_df_interaction)
}
if (CALC_CONTRASTS && CALC_INTERACTION) {
  DE_genes_combined = unique (c(DE_genes, DE_genes_interaction))
}

#get top n DE genes based on min padj in any comparison, sorted by this padj
#currently only implemented for DE genes from contrasts

if (SHOW_TOP_GENES_IN_HEATMAP) {
  top_DE_genes = get_top_DE_genes (stats_df, NR_TOP_GENES)
} else {
  top_DE_genes = DE_genes
  if (CALC_INTERACTION) {
    top_DE_genes_interaction = DE_genes_interaction
  }
  if (CALC_CONTRASTS && CALC_INTERACTION) {
    top_DE_genes_combined = DE_genes_combined
  }
}

```

##ALTERNATIVE: Get gene list from file

```{r get_DE_genes_from_file}

#Get gene names from file, assuming they are in the first column

file_name = "gene_list_example.txt"
gene_list = get_genes_from_file (file_name, has_header=T)

```

# OPTIONAL: Subset samples for clustering, visualization and export to excel

```{r samples_subset}

#store original datasets before subsetting

col_data_orig = col_data
norm_log_counts_orig = norm_log_counts
norm_counts_orig = norm_counts

#create subsets of the relevant datasets

col_data = col_data %>% filter (Age == "Young") %>% droplevels #modify as needed

samples = row.names(col_data)
norm_log_counts = norm_log_counts[, samples]   #for clustering and visualization
norm_counts = norm_counts[, samples]           #for excel output

```

# Hierarchical clustering

## Heatmap of DE genes any contrast

```{r hierarchical_clustering}

#plot heatmap for a list of genes (in this case, top DE genes)
#add col names from col_data and row names from "up", "down" per contrast from stats_df

#get norm_log_counts counts
mat2plot = filter_expression_matrix_by_gene_list (norm_log_counts, top_DE_genes)

#construct graph title
nr_genes = length(top_DE_genes)
if (SHOW_TOP_GENES_IN_HEATMAP) {
  title = paste0("Hierarchical clustering of top DE genes (n=", nr_genes, ")")
} else {
  title = paste0("Hierarchical clustering of DE genes (n=", nr_genes, ")")
}

#plot heatmap

file_name = paste0 (plots_dir, "/Heatmap_DE_genes.png") #specify output file

pheatmap_data_DE_genes = plot_expression_heatmap(mat2plot, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title)

#plot long heatmap 

file_name = paste0 (plots_dir, "/Heatmap_DE_genes_long.png")

pheatmap_data_DE_genes = plot_expression_heatmap(mat2plot, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title, plot_width=23, plot_height=40)

#plot long heatmap without col and row annotation, without sample names and without dendogram
#(feel free to change the parameters as necessary)

file_name = paste0 (plots_dir, "/Heatmap_DE_genes_long_clean.png")

pheatmap_data_DE_genes = plot_expression_heatmap(mat2plot, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title, plot_width=23, plot_height=40, row_annot=F, col_annot=F, show_sample_names=F, show_dend=F)

#store in gene lists as one cluster of all DE genes

if(SHOW_TOP_GENES_IN_HEATMAP) {
  #if we don't have a heatmap of all DE genes (but only the top DE genes), use unordered gene list of all DE genes
  clusters = setNames(rep("all", length(DE_genes)), DE_genes)
} else {
  #if we have a heatmap of all DE genes, use the ordered list from the hierarchihcal clustering result
  ordered_DE_genes = pheatmap_data_DE_genes$tree_row$labels[pheatmap_data_DE_genes$tree_row$order]
  clusters = setNames(rep("all", length(ordered_DE_genes)), ordered_DE_genes)
}
gene_lists[["all_DE"]][["any_contrast"]] = clusters


```

## Heatmap of interaction only

```{r hierarchical_clustering}

if (CALC_INTERACTION) {
  #get norm_log_counts counts
  mat2plot = filter_expression_matrix_by_gene_list (norm_log_counts, top_DE_genes_interaction)
  
  #construct graph title
  nr_genes = length(top_DE_genes_interaction)
  if (SHOW_TOP_GENES_IN_HEATMAP) {
    title = paste0("Hierarchical clustering of top genes with significant interaction (n=", nr_genes, ")")
  } else {
    title = paste0("Hierarchical clustering of genes with significant interaction (n=", nr_genes, ")")
  }
  
  #specify output file
  file_name = paste0 (results_dir, "/", "Heatmap_interaction_genes.png")
  file_name1 = paste0 (results_dir, "/", "Heatmap_interaction_genes_wo_row_annot.png")
  
  #plot heatmap
  
  pheatmap_data_interaction_genes = plot_expression_heatmap(mat2plot, EFFECTS, stats_df_combined, col_data, file_name, color_range="red2blue", plot_title=title)
  pheatmap_data_interaction_genes1 = plot_expression_heatmap_wo_contrasts(mat2plot, EFFECTS, stats_df_interaction, col_data, file_name1, color_range="red2blue", plot_title=title)

  #store in gene lists as one cluster of all interaction genes
  
  if(SHOW_TOP_GENES_IN_HEATMAP) {
    #if we don't have a heatmap of all combined genes (but only the top combined genes), use unordered gene list of all combined genes
    clusters = setNames(rep("all", length(DE_genes_interaction)), DE_genes_interaction)
  } else {
    #if we have a heatmap of all DE genes, use the ordered list from the hierarchihcal clustering result
    ordered_interaction_genes = pheatmap_data_interaction_genes$tree_row$labels[pheatmap_data_interaction_genes$tree_row$order]
    clusters = setNames(rep("all", length(ordered_interaction_genes)), ordered_interaction_genes)
  }
  gene_lists[["all_DE"]][["interaction"]] = clusters
  
}


```
## Heatmap of DE genes combined (any contrast or interaction)

```{r hierarchical_clustering}

if (CALC_CONTRASTS && CALC_INTERACTION) {
  #get norm_log_counts counts
  mat2plot = filter_expression_matrix_by_gene_list (norm_log_counts, top_DE_genes_combined)
  
  #construct graph title
  nr_genes = length(top_DE_genes_combined)
  if (SHOW_TOP_GENES_IN_HEATMAP) {
    title = paste0("Hierarchical clustering of top DE & interaction genes combined (n=", nr_genes, ")")
  } else {
    title = paste0("Hierarchical clustering of DE & interaction genes combined (n=", nr_genes, ")")
  }
  
  #specify output file
  file_name = file.path (plots_dir, "Heatmap_DE_genes_combined.png")
  
  #plot heatmap
  
  pheatmap_data_combined_genes = plot_expression_heatmap(mat2plot, EFFECTS, stats_df_combined, col_data, file_name, color_range="red2blue", plot_title=title)
  
  #store in gene lists as one cluster of all interaction genes
  
  if(SHOW_TOP_GENES_IN_HEATMAP) {
    #if we don't have a heatmap of all combined genes (but only the top combined genes), use unordered gene list of all combined genes
    clusters = setNames(rep("all", length(DE_genes_combined)), DE_genes_combined)
  } else {
    #if we have a heatmap of all DE genes, use the ordered list from the hierarchihcal clustering result
    ordered_combined_genes = pheatmap_data_combined_genes$tree_row$labels[pheatmap_data_combined_genes$tree_row$order]
    clusters = setNames(rep("all", length(ordered_combined_genes)), ordered_combined_genes)
  }
  gene_lists[["all_DE"]][["combined"]] = clusters
}

```
# Binary patterns analysis

## All binary patters

```{r corr_to_patterns}

# Binary pattern analysis is done on all DE genes

# create binary patterns directory (within results_dir) if does not exist
binary_patterns_dir = file.path(clustering_dir, "Binary_patterns") %>% create_dir

# define result files
corr_to_patterns_file       = sprintf("%s/corr_results_%s.txt",     binary_patterns_dir,analysis_name)
corr_to_patterns_stats_file = sprintf("%s/corr_stats_%s.txt"  ,     binary_patterns_dir,analysis_name)

# get replicate structure from experiment design
replicates_structure = get_replicate_struct_from_coldata (col_data, GROUP)

# calc pattern length from col_data
pattern_length = length(levels(col_data[[GROUP]]))

# get all possible patterns
patterns = get_all_possible_binary_patterns (pattern_length)

# filter norm_log_counts and norm_counts to only include DE genes
norm_log_counts_DE         = filter_expression_matrix_by_gene_list (norm_log_counts, DE_genes)
norm_counts_DE = filter_expression_matrix_by_gene_list (norm_counts, DE_genes)

#for each pattern, calc. whether the samples in the 1s all have no. counts above a cutoff
#the cutoff is applied on the norm counts (not norm_log_counts)
count_cutoff_per_pattern_matrix = calc_pattern_1s_pass_min_counts (norm_counts_DE, patterns, replicates_structure, COUNTS_CUTOFF)

#calc correlation of each gene to each pattern, and store in a matrix
#if the list of patterns is too large, consider taking only a subset of it (e.g., pass to the function patterns[1:10]).
corrs  = calc_correlations_to_expression_patterns (norm_log_counts_DE, patterns, replicates_structure)
binary_pattern_results = calc_best_pattern_per_gene (corrs, CORR_CUTOFF, corr_to_patterns_file, corr_to_patterns_stats_file, count_cutoff_per_pattern_matrix)
corrs2 = binary_pattern_results$corrs2
binary_patterns_stats = binary_pattern_results$binary_patterns_stats

```

## ALTERNATIVE: One given pattern

```{r correlation_to_one_pattern}

# find correlation to one given pattern

pattern = '00000111'  #example pattern

## get genes with correlation to a certain pattern above a certain cutoff (even if it is not the best pattern)
## by default the result is sorted by corr (desc)
corr_gene_list = get_genes_with_corr_to_pattern (corrs, pattern, CORR_CUTOFF)

## get genes with correlation to a best pattern, by default the result is sorted by corr (desc)
best_corr_gene_list = get_genes_with_corr_to_best_pattern (corrs2, pattern)

## filter gene expression matrix (norm_log_counts) to only include genes with correlation to best pattern
norm_log_counts_corr = filter_expression_matrix_by_gene_list(norm_log_counts, best_corr_gene_list)

```

## Heatmap of all binary patterns

```{r heatmaps_all_patterns}

#initialize a clusters object for the binary patterns
binary_pattern_clusters = c()

for (pattern in patterns) {
  # neglect patterns  "0000" and "1111"
  if (pattern == paste(rep(0, pattern_length), collapse ="") || pattern == paste(rep(1, pattern_length), collapse ="")) next
  print (pattern)
  genes2plot_corr = get_genes_with_corr_to_best_pattern (corrs2, pattern)
  nr_genes = length(genes2plot_corr)
  
  #add the genes to the clusters object for later storage in the gene_lists list object
  pattern_name = paste0("_", pattern)
  binary_pattern_cluster = c(rep(pattern_name, length(genes2plot_corr))) #a named vector with genes as names and pattern as values
  names(binary_pattern_cluster) = genes2plot_corr
  binary_pattern_clusters = c(binary_pattern_clusters, binary_pattern_cluster)

  #print heatmap
  if (nr_genes <2) next
  mat2plot = filter_expression_matrix_by_gene_list(norm_log_counts_DE, genes2plot_corr)  #Vered 25.12.2023 I think the first parameter can also be norm_log_counts, but did not check that
  file_name = paste0 (binary_patterns_dir, "/", "Heatmap_", pattern, ".png")
  title = paste0 ("Pattern ", pattern, " (", nr_genes, " genes)")
  plot_expression_heatmap(mat2plot, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title)
}

#store patterns' gene lists
nr_clusters = length(unique(binary_pattern_clusters))
clustering_instance = paste0(nr_clusters, "_patterns")
gene_lists[["binary_patterns"]][[clustering_instance]] = binary_pattern_clusters

```
# Partition clustering

## Do clustering and plot cluster profiles

```{r heatmaps_DeSeq2_module}

# Partition clustering (as in DeSeq2 module)

#get a list of genes (in this case, top DE genes)
#compute hierarchical clustering followed by partition clustering using group averages
#them draw hierarchical clustering per cluster
#present heatmap + average expression profile per cluster

#preparations

#get norm_log_counts counts for DE genes
mat2plot = filter_expression_matrix_by_gene_list (norm_log_counts, top_DE_genes)

#construct graph title
nr_genes = length(top_DE_genes)
if (SHOW_TOP_GENES_IN_HEATMAP) {
  title = paste0("Partitionn clustering of top DE genes (n=", nr_genes, ")")
} else {
  title = paste0("Partition clustering of DE genes (n=", nr_genes, ")")
}

#compute group means
#assuming that col order in mat2plot is the same as row order in col_data
mat2plot_means = mat2plot %>%
                 t %>%
                 aggregate.data.frame(by = col_data[GROUP],FUN = mean) %>%
                 remove_rownames %>%
                 column_to_rownames(var=GROUP) %>%
                 as.data.frame() %>%
                 t

# Z-scoring: scale expression data by row
mat2plot_means_scaled <- z_score(mat2plot_means)

#clustering of all DE genes using group means
#use group averages
#use the gap algorithm to determine the number of clusters
#this will run hierarchical clustering and then cut the tree to discrete clusters using the determined no. of clusters
#it is possible to manually determine the no. of clusters using the k parameter
#need to feed in scaled data by row, because the stand parameter in eclust scales the data by column which is bad

if (!is.na(K_FIXED)) {
  #clustering with setting no. of clusters
  Clustering <- eclust(as.matrix(mat2plot_means_scaled),
                       stand = F,
                       FUNcluster= "hclust",
                       hc_metric = "pearson",
                       graph = F,  #should be FALSE
                       hc_method = "ward.D2",
                       #k.max =  k.max,
                       k = K_FIXED
  )
} else {
  gap_maxSE_method = "firstSEmax"
  gap_maxSE_SE.factor = 1 #eclust parameter for determining the number of clusters [Not For Mclust]. higher number is less sensitive. Liron's default is 1
  
  Clustering <- eclust(as.matrix(mat2plot_means_scaled),
                       stand = F,
                       FUNcluster= "hclust",
                       hc_metric = "pearson",
                       graph = F,  #should be FALSE
                       hc_method = "ward.D2",
                       k.max =  K_MAX,
                       nboot = 10,          #no. bootstrap. consider increasing. Liron's default is 10
                       gap_maxSE = list(method= gap_maxSE_method, SE.factor = gap_maxSE_SE.factor)
  )
}

Clustering$nbclust
Clustering$size

head(Clustering$cluster)
head(Clustering$data)

#specify output files. directory name will include no. of clusters
nr_clusters = Clustering$nbclust
clustering_title = paste0("Partition_clustering_", nr_clusters, "_clusters")
partition_clustering_dir = file.path (clustering_dir, clustering_title) %>% create_dir

cluster_profiles_file  = file.path (partition_clustering_dir, "cluster_profiles.pdf")
heatmap_file_name      = file.path (partition_clustering_dir, "Partition_clustering_heatmap.png")

#get "clusters": array where element names are genes and values are cluster no. not re-ordered by clustering.
clusters=Clustering$cluster

#hierarchical clustering at the group average level of each cluster separately
#this is then concatenated to create clustering order in all the DE genes (by group averages)
#the result is used by Liron to draw the heatmap of the averages, but I did not implement it.

New_clusters=c()
for (num in sort(unique(clusters))){
  res_red=unique(names(clusters))
  Genes=res_red[res_red  %in% names(clusters[clusters %in% num])]
  if (length(Genes)>1){
    
    heat_map=pheatmap(mat = as.matrix(mat2plot_means[Genes,]),   #mat2plot_means_Z_score
                      cluster_rows = T,
                      show_rownames=F,
                      clustering_distance_rows = "correlation" ,
                      clustering_method="ward.D2",
                      cluster_cols = F,
                      silent = F,   #to display the graph, comment this line and don't assign to Heat_map, just run pheatmap
                      scale = "row" #should be "row"
                      )
    
    New_clusters=c(New_clusters,clusters[heat_map$tree_row$labels[heat_map$tree_row$order]])
  }else{
    New_clusters=c(New_clusters,clusters[Genes])
  }
}

#generation and plotting of average expression profile per cluster

table(New_clusters)  #print clustering summary

#plot graphs without smoothing, but with error bars
Clustering_Plot1 = plot_cluster_profiles(New_clusters, mat2plot, col_data, c(GROUP1,GROUP),c(GROUP1,GROUP,"Normalized counts"), smooth=F, X_AXIS_ORDER=unique(col_data[GROUP]), out_file = cluster_profiles_file)

```
## Heatmaps of clusters

```{r heatmap of pre computed clusters}

partition_clusters = plot_expression_heatmap_for_precomputed_clusters (mat2plot, New_clusters, EFFECTS, GROUP, GROUP1, col_data, heatmap_file_name, plot_title = title)

#store clustering results in gene_lists
clustering_instance = paste0(nr_clusters, "_clusters")  #if you just put cluster number as key, it may be confused with list index
gene_lists[["partition_clustering"]][[clustering_instance]] = partition_clusters

```

# Manual clustering using cutoffs

## Preparation

```{r summary stats current clusters}

#required objects

# head(mat2plot_means_scaled)
# head(gene_lists[[clustering_title]])   #results of partition clustering
# head(contrasts_data)

#NOTE: the code works on 3 biological groups. By default, it takes the first 3 cols of mat2plot_means_scaled, but you may change it in the definition of new_df

new_df = mat2plot_means_scaled[,COLUMNS_FOR_MAN_CLUSTERING] #take first 3 columns of mat2plot_means (you may change it if needed)
colnames(new_df) = c("A", "B", "C")

new_df = 
  new_df %>%
  as.data.frame %>%
  rownames_to_column(var="gene") %>%
  mutate ("B.vs.A" = B - A) %>%
  mutate ("C.vs.B" = C - B) 

```

## OPTIONAL: Analysis of previous partition clustering stats

```{r summary stats current clusters}

# Summary stats of clusters from partition clustering (after z-scoring)
# Summary statistics is computed per cluster. Note that FC is converted to linear
# This will help determine cutoffs for manual clustering

#this is done on the results of the last partition clustering performed

partition_clusters_df = make_data_frame_from_clusters(partition_clusters)
new_df0 = merge (partition_clusters_df, new_df, by.x="gene", by.y="gene")
row.names(new_df0) = new_df0$gene
new_df0 = new_df0[partition_clusters_df$gene,]  #sort lines by order of genes in partition_clusters

agg_mean =
  new_df0 %>%
  select (-gene) %>%
  aggregate.data.frame (by=list(Cluster=new_df0$cluster), FUN=mean) %>%
  mutate (B.vs.A = ifelse(B.vs.A>0,
                          yes = 2^B.vs.A,
                          no = -1/(2^B.vs.A))) %>%
  mutate (C.vs.B = ifelse(C.vs.B>0,
                          yes = 2^C.vs.B,
                          no = -1/(2^C.vs.B))) 

agg_min =
  new_df0 %>%
  select (-gene) %>%
  aggregate.data.frame (by=list(Cluster=new_df0$cluster), FUN=min) %>%
  mutate (B.vs.A = ifelse(B.vs.A>0,
                          yes = 2^B.vs.A,
                          no = -1/(2^B.vs.A))) %>%
  mutate (C.vs.B = ifelse(C.vs.B>0,
                          yes = 2^C.vs.B,
                          no = -1/(2^C.vs.B))) 

agg_max =
  new_df0 %>%
  select (-gene) %>%
  aggregate.data.frame (by=list(Cluster=new_df0$cluster), FUN=max) %>%
  mutate (B.vs.A = ifelse(B.vs.A>0,
                          yes = 2^B.vs.A,
                          no = -1/(2^B.vs.A))) %>%
  mutate (C.vs.B = ifelse(C.vs.B>0,
                          yes = 2^C.vs.B,
                          no = -1/(2^C.vs.B)))

export_table(agg_mean, paste0 (partition_clustering_dir, "/Clusters_mean.txt"))
export_table(agg_min,  paste0 (partition_clustering_dir, "/Clusters_min.txt"))
export_table(agg_max,  paste0 (partition_clustering_dir, "/Clusters_max.txt"))
```
## Generate manual clusters - option 1

```{r manual clusters}

#Clustering is done using FC cutoffs based on z-scores of vsd normalized data

#the code works on 3 biological groups of the experiment which were defined in Gloabal_parameters.R

log_man_clust_FC_cutoff = log2(MAN_CLUST_FC_CUTOFF)

cluster_def = c(1:9)
names(cluster_def) = c("up-nc", "up-down", "up-up", "nc-up", "down-nc", "down-up", "down-down", "nc-down", "nc-nc")
cat ("cluster definiton:\n")
cluster_def

#specify output files
clust_title = paste0("Manual_clusters_option1_cutoff", MAN_CLUST_FC_CUTOFF)
manual_clusters_dir_opt1 = file.path (clustering_dir, clust_title) %>% create_dir

man_cluster_profiles_file = file.path (manual_clusters_dir_opt1, "Manual_cluster_profiles.pdf")

#construct graph title for heatmap
nr_genes = length(top_DE_genes)
if (SHOW_TOP_GENES_IN_HEATMAP) {
  title = paste0("Manual clustering of top DE genes (n=", nr_genes, ")")
} else {
  title = paste0("Manual clustering of DE genes (n=", nr_genes, ")")
}

new_df1 =
  new_df %>%
  mutate (B.vs.A_direction = ifelse(B.vs.A > log_man_clust_FC_cutoff,
                                       yes="up",
                                       no=ifelse(B.vs.A < -log_man_clust_FC_cutoff,
                                                  yes="down",
                                                  no="nc"))) %>%
  mutate (C.vs.B_direction = ifelse(C.vs.B>log_man_clust_FC_cutoff,
                                       yes="up",
                                       no=ifelse(C.vs.B < -log_man_clust_FC_cutoff,
                                                  yes="down",
                                                  no="nc"))) %>%
  mutate (Pattern = paste0(B.vs.A_direction, "-", C.vs.B_direction)) %>%
  mutate (cluster = cluster_def[Pattern])

#create a clustering object as a named vector
man_clusters_opt1 <- setNames(as.numeric(new_df1$cluster), new_df1$gene) 
cat ("clustering summary:\n")
table(man_clusters_opt1)  #print clustering summary

#plot cluster profiles
#generation and plotting of average expression profile per cluster
#plot graphs without smoothing, but with error bars
man_clustering_Plot1 = plot_cluster_profiles(man_clusters_opt1,mat2plot,col_data, c(GROUP1,GROUP),c(GROUP1,GROUP,"Normalized counts"), smooth=F, X_AXIS_ORDER=unique(col_data[GROUP]), out_file = man_cluster_profiles_file)

man_clustering_Plot1

```

## Heatmaps of manual clusters - option 1

``` {r plot man clusters heatmap}

#plot heatmap of manual clusters and store results

heatmap_file_name = file.path (manual_clusters_dir_opt1, "Manual_clustering_heatmap.png")
man_clusters_opt1_ordered = plot_expression_heatmap_for_precomputed_clusters (mat2plot, man_clusters_opt1, EFFECTS, GROUP, GROUP1, col_data,
                                                                              heatmap_file_name, plot_title = title)

#store in gene_lists
nr_clusters = length(unique(man_clusters_opt1))
clustering_instance = paste0("FC", MAN_CLUST_FC_CUTOFF)
gene_lists[["manual_clustering"]][[clustering_instance]] = man_clusters_opt1_ordered

#print plots with other display settings

#plot long heatmap of manual clusters
heatmap_file_name = file.path (manual_clusters_dir_opt1, "Manual_clustering_heatmap_long.png")
man_clusters_opt1_ordered1 = plot_expression_heatmap_for_precomputed_clusters (mat2plot, man_clusters_opt1, EFFECTS, GROUP, GROUP1, col_data,
                                                                              heatmap_file_name, plot_title = title,
                                                                              plot_width=23, plot_height=40, scale=0.7, print_file_per_cluster=F)

#plot long heatmap of manual clusters wo col and row annotation, without sample names and wo dendogram
heatmap_file_name = file.path (manual_clusters_dir_opt1, "Manual_clustering_heatmap_long_clean.png")
man_clusters_opt1_ordered2 = plot_expression_heatmap_for_precomputed_clusters (mat2plot, man_clusters_opt1, EFFECTS, GROUP, GROUP1, col_data,
                                                                              heatmap_file_name, plot_title = title,
                                                                              plot_width=23, plot_height=40, row_annot=F, col_annot=F, show_sample_names=F,
                                                                              show_dend=F, scale=0.7, print_file_per_cluster=F)

```

## Generate manual clusters - option 2

```{r manual clusters}

#cutoffs are based on DESeq2 stats results (done on orig counts)

#IMPORTANT NOTE: contrast names are hard coded below!!! change them to match the experiment at hand

cluster_def = c(1:9)
names(cluster_def) = c("up-nc", "up-down", "up-up", "nc-up", "down-nc", "down-up", "down-down", "nc-down", "nc-nc")
cat ("cluster definition:")
cluster_def

#specify output files
manual_clusters_dir_opt2 = file.path(clustering_dir, "Manual_clusters_option2") %>% create_dir

man_cluster_profiles_file = file.path (manual_clusters_dir_opt2, "Manual_cluster_profiles.pdf")

#construct graph title for heatmap
nr_genes = length(top_DE_genes)
if (SHOW_TOP_GENES_IN_HEATMAP) {
  title = paste0("Manual clustering option 2 of top DE genes (n=", nr_genes, ")")
} else {
  title = paste0("Manual clustering option 2 of DE genes (n=", nr_genes, ")")
}

new_df2 = 
  stats_df %>%
  filter (gene %in% top_DE_genes) %>%
  select (gene, linearFC.H.vs.L, pvalue.H.vs.L, linearFC.R.vs.H, pvalue.R.vs.H) %>%
  setNames (c("gene", "linearFC.B.vs.A", "pvalue.B.vs.A", "linearFC.C.vs.B", "pvalue.C.vs.B")) %>%
  mutate (B.vs.A_direction = ifelse(((!is.na(linearFC.B.vs.A)) & (!is.na(pvalue.B.vs.A)) & (pvalue.B.vs.A < MAN_CLUST_DESEQ_P_CUTOFF)),
          yes=ifelse(linearFC.B.vs.A > MAN_CLUST_DESEQ_FC_CUTOFF,
          yes="up",
          no=ifelse(linearFC.B.vs.A < -MAN_CLUST_DESEQ_FC_CUTOFF,
          yes="down",
          no="nc")),
          no="nc")) %>%
    mutate (C.vs.B_direction = ifelse(((!is.na(linearFC.C.vs.B)) & (!is.na(pvalue.C.vs.B)) & (pvalue.C.vs.B < MAN_CLUST_DESEQ_P_CUTOFF)),
          yes=ifelse(linearFC.C.vs.B > MAN_CLUST_DESEQ_FC_CUTOFF,
          yes="up",
          no=ifelse(linearFC.C.vs.B < -MAN_CLUST_DESEQ_FC_CUTOFF,
          yes="down",
          no="nc")),
          no="nc")) %>%
  mutate (Pattern = paste0(B.vs.A_direction, "-", C.vs.B_direction)) %>%
  mutate (cluster = cluster_def[Pattern])

man_clusters_opt2 <- setNames(as.numeric(new_df2$cluster), new_df2$gene)

cat ("clustering summary:\n")
table(man_clusters_opt2)  #print clustering summary

#plot cluster profiles
#generation and plotting of average expression profile per cluster
#plot graphs without smoothing, but with error bars
man_clustering_Plot2 = plot_cluster_profiles(man_clusters_opt2, mat2plot,col_data, c(GROUP1,GROUP),c(GROUP1,GROUP,"Normalized counts"), smooth=F, X_AXIS_ORDER=unique(col_data[GROUP]), out_file = man_cluster_profiles_file)

man_clustering_Plot2
```

## Heatmaps of manual clusters - option 2

``` {r plot man clusters heatmap}

#plot heatmap of manual clusters and store results

heatmap_file_name = file.path (manual_clusters_dir_opt2, "Manual_clustering_heatmap.png")
man_clusters_opt2_ordered = plot_expression_heatmap_for_precomputed_clusters (mat2plot, man_clusters_opt2, EFFECTS, GROUP, GROUP1, col_data, heatmap_file_name, plot_title = title)

#store in gene_lists
nr_clusters = length(unique(man_clusters_opt2))
clustering_instance = paste0("FC", MAN_CLUST_DESEQ_FC_CUTOFF, "_p", MAN_CLUST_DESEQ_P_CUTOFF)
gene_lists[["manual_clustering_opt2"]][[clustering_instance]] = man_clusters_opt2_ordered

#print plots with other display settings

#plot long heatmap of manual clusters
heatmap_file_name = file.path (manual_clusters_dir_opt2, "Manual_clustering_heatmap_long.png")
man_clusters_opt2_ordered = plot_expression_heatmap_for_precomputed_clusters (mat2plot, man_clusters_opt2, EFFECTS, GROUP, GROUP1, col_data,
                                                                              heatmap_file_name, plot_title = title,
                                                                              plot_width=23, plot_height=40, scale=0.7, print_file_per_cluster=F)

#plot long heatmap of manual clusters wo col and row annotation, without sample names and wo dendogram
heatmap_file_name = file.path (manual_clusters_dir_opt2, "Manual_clustering_heatmap_long_clean.png")
man_clusters_opt2_ordered = plot_expression_heatmap_for_precomputed_clusters (mat2plot, man_clusters_opt2, EFFECTS, GROUP, GROUP1, col_data,
                                                                              heatmap_file_name, plot_title = title, plot_width=23, plot_height=40,
                                                                              row_annot=F, col_annot=F, show_sample_names=F,
                                                                              show_dend=F, scale=0.7, print_file_per_cluster=F)

```

## Get average expression per cluster (for export)

``` {r get average expression per cluster}

#The function is not yet ready.currently it just prints data to file for further manipulation in excel

#here we do it for manual clustering option 1
clusters = man_clusters_opt1
manual_clusters_dir = manual_clusters_dir_opt1

for (num in sort(unique(clusters))){  #for each cluster
  #get a list of the genes in this cluster
  Genes = get_genes_per_cluster(clusters, num)
  
  if (length(Genes)>1){
    expression_matrix = mat2plot[Genes,]
    out_file = paste0 (manual_clusters_dir, "/", "cluster_", num, "_expression.csv")
    write.csv(expression_matrix, file=out_file)
  }
}

```

## Unify clusters

``` {r unify clusters}

#here we do it for manual clustering option 1
clusters = man_clusters_opt1

#define how to unify the clusters (hard coded)
unified_clusters = clusters %>%
  case_match (c(1,5) ~ "persistent",
              c(2,6) ~ "reversed",
              c(3,7) ~ "aggravated",
              c(4,8) ~ "reverse_effect",
              .default = "other"
              )

# unified_clusters = clusters %>%
#   case_match (c(1,3,4) ~ "up",
#               c(5,7,8) ~ "down",
#               .default = "other"
#               )

names(unified_clusters) = names(clusters)

table(unified_clusters)

#store in gene_lists
nr_clusters = length(unique(unified_clusters))
clustering_instance = paste0(nr_clusters, "_clusters")
gene_lists[["unified_clusters"]][[clustering_instance]] = unified_clusters

```
# Export results to Excel

## Prepare results data frame

```{r prepare results data frame}

#initialize res_df with gene names as first column

res_df = data.frame(gene=rownames(norm_counts))

#add gene annotation
#use the first column of the annotation data frame as key

if (exists("annot")) {
     res_df3 <- merge(x   = res_df,
                    y     = annot,
                    by.x  = "gene",
                    by.y  = 1,
                    all.x = TRUE)
    dim(res_df)
    dim(res_df3)
    if (identical(dim(res_df)[1],dim(res_df3)[1])) {
        res_df<-res_df3
        rm(res_df3)
        gc()
    } else {
        cat("Error!!!")
    }
}

nr_first_cols = dim(res_df)[2]

#add norm counts

res_df = cbind(res_df, norm_counts)

#add stats results

if (CALC_CONTRASTS & CALC_INTERACTION) {
  res_df = cbind(res_df, select(stats_df_combined, -gene))
} else if (CALC_CONTRASTS) {
  res_df = cbind(res_df, select(stats_df, -gene))
} else if (CALC_INTERACTION) {
  res_df = cbind(res_df, select(stats_df_interaction, -gene))
}

#add trinotate
if (exists("trinotate_main")) {
    res_df2 <- merge(x     = res_df,
                    y     = trinotate_main,
                    by.x  = "gene",
                    by.y  = "X.gene_id",
                    all.x = TRUE)
    dim(res_df)
    dim(res_df2)
    if (identical(dim(res_df)[1],dim(res_df2)[1])) {
        res_df<-res_df2
        rm(res_df2)
        gc()
    } else {
        cat("Error!!!")
    }
}

#check
(res_df$gene %>% length) == (unique(res_df$gene) %>% length)

#backup res df
res_df1=list(res_df=res_df)
 save(res_df1,file = "res_df_backup.R")

```

## Prepare first rows (for column headers)

```{r prepare top rows}

  # This section prepares metadata_rows, contrasts_header and grouping_header

  ## Prepare data to write:
  
  metadata_cols = EFFECTS
  metadata_rows <- length(metadata_cols)+1

  # initialize contrasts header with empty titles for the expression data
  
  #contrasts_header = c("Transcript", rep("", nrow(col_data)))
  contrasts_header = c(rep ("", nr_first_cols+nrow(col_data)))
  
  # grouping_header stores widths of data groups.
  # initialize it with a group of 1 for gene name, and a second group with the number of samples for expression data
  
  grouping_header <- c(nr_first_cols, ncol(norm_counts))
  
  # add headers for contrasts
  
  res_dim2 <- 5 # Columns per contrast in res_df: linearFC, pvalue, padj, manual formula and pass
  
  for (i in 1:nrow(contrasts_data)) {
    contrast_name = contrasts_data[i,'Contrast_name']
    contrasts_header <- c(contrasts_header,
                          contrast_name,
                          rep(NA, res_dim2 - 1))
    # Add width of group to grouping_header
    grouping_header <- c(grouping_header,res_dim2)
  }
  
  #add headers for pass any 
  
  contrasts_header <- c(contrasts_header, "")
  grouping_header <- c(grouping_header,1)
  
  #add headers for interaction (if relevant)
  
  if (CALC_INTERACTION) {
    #add headers and space for p-value, adj, pass
    contrasts_header <- c(contrasts_header, "Interaction", "", "") 
    grouping_header <- c(grouping_header,3)
  }
  
  if (CALC_CONTRASTS & CALC_INTERACTION) {
    #add header and space for pass_combined
    contrasts_header <- c(contrasts_header, "") 
    grouping_header <- c(grouping_header,1)
  }
  
  #add headers for trinotate
  
  if (exists("trinotate_main")) {
    contrasts_header <- c(contrasts_header, 
                          rep("Trinotate",
                              ncol(trinotate_main)-1)) 
    grouping_header <- c(grouping_header, ncol(trinotate_main)-1) }
  
  # In case these have been expanded below, keeping only the part from res_df:
  #contrasts_header <- contrasts_header[1:ncol(res_df)]
  #grouping_header <- grouping_header[cumsum(grouping_header) <= ncol(res_df)]
  
  #extending headers for the DE, interaction and combined files
  
  contrasts_header_DE = c(contrasts_header,"")  
  grouping_header_DE <- c(grouping_header,1)  # Including 'order' column 
  
  grouping_header_DE <- c(grouping_header_DE,2)  # Including cluster no. and order from DeSeq2 module clustering (27.4.2023)
  
  if(PERFORM_MANUAL_CLUSTERING) {
    grouping_header_DE <- c(grouping_header_DE,2)  # Including manual cluster no. and order from DeSeq2 module clustering (27.4.2023)
    
  }
  
  contrasts_header_DE = c(contrasts_header_DE,rep("",dim(col_data)[1]))  
  # Save widths of data groups:
  grouping_header_DE <- c(grouping_header_DE,ncol(norm_counts))  # Including zscores
  
```  
  
## Output all genes

```{r output_all_genes_to_excel}

res_df2write = write_all_genes_to_Excel (res_df)

```

## Output DE genes, interaction and combined files

```{r create_DE_genes_tab}
if (CALC_CONTRASTS) {
  write_DE_genes_to_Excel (res_df2write)
}
if (CALC_INTERACTION) {
  write_interaction_genes_to_Excel (res_df2write)
}
if (CALC_CONTRASTS & CALC_INTERACTION) {
  write_combined_genes_to_Excel (res_df2write)
}

```
# Summarise gene lists

```{r GO enrichmentl}

for (key in names(gene_lists)) {
  cat (paste0(key, ":\n"))

  for (type in names(gene_lists[[key]])) {
    cat (type)
    cat (" (")
    cat (unique(gene_lists[[key]][[type]]))
    cat (")\n")
  }
  cat ("\n")
}
  
```

# Enrichment - preparations

```{r read_func_annot_from_files}

#This section is relevant for both classical (Fisher's exact test) and GSEA enrichment analyses

#Read functional annotation data from files

#KEGG

Pathway2name_file = file.path(functional_annot_dir,'KEGG_pathway2name.tab')
Pathway2gene_file = file.path(functional_annot_dir,'KEGG_pathway2gene.tab')

Pathway2name = read.delim(Pathway2name_file, sep="\t", row.names=NULL)
Pathway2gene = read.delim(Pathway2gene_file, sep="\t", row.names=NULL)

#GO

GO_data = list()
for (GO_type in c('BP', 'MF', 'CC')) {
  for (file_type in c("GO2gene", "GO2name")) {
    file = file.path(functional_annot_dir, paste0(file_type, "_", GO_type, ".tab")) #e.g. "GO2gene_BP.tab"
    GO_data[[GO_type]][[file_type]] = read.delim(file, sep="\t", row.names=NULL)
  }
}

#Initialize data structures to hold enrichment results, for further analyses and for delivery to RShiny

enrichment_results      = list()
enrichment_table        = list()
GSEA_enrichment_results = list()

#Prepare ranked gene lists wo filtering (for GSEA and for ridgplots)

ranked_genes = list()

### per contrast

for (contrast in contrasts_data$Contrast_name) {

  cat (contrast, "\n")
    
  #by p-value without direction of change
  ranked_genes[["pval_wo_direction"]][[contrast]]   = create_ranked_genes_by_pval_wo_direction (stats_df, contrast)
  
  #by p-value with direction of change
  ranked_genes[["pval_with_direction"]][[contrast]] = create_ranked_genes_by_pval_with_direction (stats_df, contrast)
  
  #by FC
  ranked_genes[["fc"]][[contrast]] = create_ranked_genes_by_fc (stats_df, contrast)
}

cat ("Any contrast\n")

#by min p-value in any contrast
ranked_genes[["pval_wo_direction"]][["any_contrast"]] = get_ranked_genes_by_min_pval_any_contrast (stats_df)

```

# Enrichment - Fisher's exact test

## KEGG enrichment

```{r KEGG enrichmentl Ensembl Uniprot}

enrich_results_dir = file.path (enrich_results_main_dir, "KEGG") %>% create_dir

#run enrichment tests
#per cluster

# #just one list, for testing:
# clusters = man_clusters_opt1
# result_file = "KEGG_manual_clustering_8_clusters"

cat("Starting KEGG enrichment\n")

for (clust_method in names(gene_lists)) {
  cat (paste0(clust_method, ":\n"))
  for (clust_round in names(gene_lists[[clust_method]])) {
    cat (clust_round, "\n")
    
    #compute enrichment
    clusters = gene_lists[[clust_method]][[clust_round]]
    result_file = paste0("KEGG_", clust_method, "_", clust_round)
    
    allRes  <- Clusters_Enrichment_Test(Type="KEGG", clusters=clusters,
                                        TERM2NAME=Pathway2name, TERM2GENE=Pathway2gene,
                                        outDir=enrich_results_dir, file_name=result_file,
                                        pvalueCutoff=ENRICHMENT_PVAL_CUTOFF, pAdjustMethod=ENRICHMENT_PADJ_METHOD,
                                        gene2ko=FALSE, maxCategory = MAX_TERMS_IN_DOTPLOT)
        
    if (length(allRes) !=0) {
      #store enrichment results object for drawing shared genes/pathways for specific clustering rounds
      enrichment_results [["KEGG"]][[clust_method]][[clust_round]] = allRes[[1]]
      #store enrichment result table for delivery to Rshiny
      enrichment_table   [["KEGG"]][[clust_method]][[clust_round]] = allRes[[3]]
    } else {
      cat ("(no enrichment)")
    }
  }
  cat ("\n")
}

#draw ridgeplots for selected gene lists/clusters
    
ridgeplots_dir = file.path(enrich_results_dir, "ridgeplots") %>% create_dir

print (names(gene_lists))                 #show all options for clust_method
print (names(gene_lists[[clust_method]])) #show all options for clust_round
print (sort(unique(clusters)))            #show all options for cluster_name
print (contrasts_data$Contrast_name)      #show all options for contrast

clust_method = "unified_clusters"
clust_round  = "4_clusters"
# cluster_name = "aggravated"
# contrast     = "Y_Reverse.vs.NC"  #for display of FC in X-axis (it is cluster_specific)

#note - this is analysis-specific. modify as needed
contrast_per_cluster = c("persistent"     = "HFD.vs.NC",
                         "reversed"       = "HFD.vs.NC",
                         "aggravated"     = "Reverse.vs.NC",
                         "reverse_effect" = "Reverse.vs.HFD")

for (cluster_name in sort(unique(clusters))) {
  contrast = contrast_per_cluster[cluster_name]
  print (paste (cluster_name, contrast))
  
  ridgeplots_dir1  = file.path(ridgeplots_dir, paste0(clust_method, "_", clust_round)) %>% create_dir
  
  #to show FC in x axis
  ranked_genes_by_fc = ranked_genes[["fc"]][[contrast]]
  values_for_x_axis = ranked_genes_by_fc
  
  ridgeplot_file = file.path(ridgeplots_dir1, paste0(cluster_name, "_X_by_", contrast, ".png"))
  x_axis_title = "log2(FC)"
  
  draw_ridgeplot_per_cluster (clust_method, clust_round, cluster_name, values_for_x_axis, ridgeplot_file, TERM2NAME=Pathway2name,TERM2GENE=Pathway2gene, pvalueCutoff=ENRICHMENT_PVAL_CUTOFF, pAdjustMethod=ENRICHMENT_PADJ_METHOD)
}


```
## OPTIONAL: KEGG plot shared genes among pathways

```{r KEGG shared genes}

#create heatmaps of gene2term and term2term overlaps

#since this takes time and space, it is not included in the loop over all clustering methods and rounds.
#instead, specify here the requested clustering method and round

clust_method = "manual_clustering"
clust_round =  "FC1.2"
#or:
#enrichment_result = enrichment_results[["KEGG"]][["contrasts"]][["M_Reverse.vs.NC"]]

enrichment_result  = enrichment_results[["KEGG"]][[clust_method]][[clust_round]]
enrichment_data    = enrichment_result@compareClusterResult

enrich_results_dir2 = file.path (enrich_results_main_dir, "KEGG", "Shared_genes_among_pathways") %>% create_dir
enrich_results_dir3 = file.path (enrich_results_dir2, paste0(clust_method, "_", clust_round)) %>% create_dir

heatmaps = plot_shared_genes (enrichment_data, enrich_results_dir3,'KEGG')

```
## GO enrichment

```{r GO enrichmentl}  

#GO enrichment

#NOTE: the enrichment analysis of the results of all clustering methods and rounds may take a long time
#You may select only one clust_mothod or clust_round as specified in a comment inside the loop below

cat("Starting GO enrichment\n")

for (clust_method in names(gene_lists)) {
  cat (paste0(clust_method, ":\n"))
  for (clust_round in names(gene_lists[[clust_method]])) {
    cat (clust_round, "\n")
    
    # for one specific analysis, start here and specify (for example):
    # clust_method = "manual_clustering"
    # clust_round  = "FC1.2"

    for (GO_type in c('BP', 'MF', 'CC')){   #c('BP', 'MF', 'CC') or part of it
      
      GO_type_title          = paste0("GO", "_", GO_type)
      GO_type_title_simplify = paste0("GO", "_", GO_type, "_simplify")
      cat(GO_type_title, "\n")
      
      GO2gene = GO_data[[GO_type]][["GO2gene"]]
      GO2name = GO_data[[GO_type]][["GO2name"]]
      
      enrich_results_dir = file.path(enrich_results_main_dir, GO_type_title)  %>% create_dir
      
      #compute enrichment
      clusters = gene_lists[[clust_method]][[clust_round]]
      result_file = paste0(GO_type_title, "_", clust_method, "_", clust_round)
      
      allRes  <- Clusters_Enrichment_Test(Type="GO", clusters=clusters,
                                          TERM2NAME=GO2name, TERM2GENE=GO2gene,
                                          outDir=enrich_results_dir, file_name=result_file,
                                          pvalueCutoff=ENRICHMENT_PVAL_CUTOFF, pAdjustMethod=ENRICHMENT_PADJ_METHOD,
                                          gene2ko=FALSE, maxCategory = MAX_TERMS_IN_DOTPLOT)
      
      #store enrichment results object for drawing shared genes/pathways for specific clustering rounds
      enrichment_results          [[GO_type_title]][[clust_method]][[clust_round]] = allRes[[1]]
      enrichment_results [[GO_type_title_simplify]][[clust_method]][[clust_round]] = allRes[[2]]
      #store enrichment result table for delivery to Rshiny
      enrichment_table            [[GO_type_title]][[clust_method]][[clust_round]] = allRes[[3]]
      enrichment_table   [[GO_type_title_simplify]][[clust_method]][[clust_round]] = allRes[[4]]
    }
    cat ("\n")
  }
  cat ("\n")
}

```
## OPTIONAL: GO plot   shared genes among pathways

```{r GO shared genes}

#create heatmaps of gene2term and term2term overlaps

#since this takes time and space, it is not included in the loop over all clustering methods and rounds.
#instead, specify here the requested clustering method and round and the requested go type
#also, specify if you wish to use regular or "simplify" GO enrichment

GO_type_title = "GO_BP"
clust_method  = "manual_clustering"
clust_round   = "FC1.2"
use_simplify  = F

if (use_simplify) {
  GO_type_title1 = paste0(GO_type_title, "_simplify")
  enrichment_result = enrichment_results[[GO_type_title1]][[clust_method]][[clust_round]]
  subdir = paste0(clust_method, "_", clust_round, "_simplify")
} else {
  enrichment_result = enrichment_results[[GO_type_title]][[clust_method]][[clust_round]]
  subdir = paste0(clust_method, "_", clust_round)
}
enrichment_data   = enrichment_result@compareClusterResult

enrich_results_dir2 = file.path (enrich_results_main_dir, GO_type_title, "Shared_genes_among_pathways") %>% create_dir
enrich_results_dir3 = file.path (enrich_results_dir2, subdir) %>% create_dir

heatmaps = plot_shared_genes (enrichment_data, enrich_results_dir3, GO_type_title)

```

#    Enrichment - GSEA

## GSEA - KEGG

```{r KEGG enrichmentl GSEA}

#run GSEA

GSEA_results_dir  = file.path(GSEA_results_main_dir, "KEGG") %>% create_dir

for (ranking_method in names(ranked_genes)) {
  cat (ranking_method, "\n")
  GSEA_results_dir1 = file.path(GSEA_results_dir, paste0("ranking_by_", ranking_method)) %>% create_dir
  for (contrast in names(ranked_genes[[ranking_method]])) {
    cat (contrast, "\n")
    GSEA_results_dir2 = file.path(GSEA_results_dir1, contrast) %>% create_dir
    ranked_genes_to_analyze = ranked_genes[[ranking_method]][[contrast]]
    
    nr_total_genes = length(unique(Pathway2gene[,2]))  #no. of genes having assigned pathways
    res=GSEA (
      geneList      = ranked_genes_to_analyze,
      TERM2GENE     = Pathway2gene, 
      TERM2NAME     = Pathway2name,
      minGSSize     = 4,
      maxGSSize     = nr_total_genes,
      pAdjustMethod = ENRICHMENT_PADJ_METHOD,
      pvalueCutoff  = ENRICHMENT_PVAL_CUTOFF)
    
    #store for RShiny
    GSEA_enrichment_results[["KEGG"]][[ranking_method]][[contrast]] = res
    
    #print results
    GSEA_results = data.frame(res)
    GSEA_results_file = file.path(GSEA_results_dir2, paste0 ("GSEA_results_", contrast, ".csv"))
    write.csv(GSEA_results, file=GSEA_results_file, row.names = F)
    
    #print ridge plots
    
    if (nrow(GSEA_results) > 0) {
      
      #print the default ridge plot (where x-axis shows the ranking value used for GSEA)
      
      #set x-axis title
      x_axis_title = ""
      if (ranking_method == "fc") {
        x_axis_title = "log2(FC)"
      } else if (ranking_method == "pval_wo_direction") {
        x_axis_title = "-log10(p-value)"
      } else if (ranking_method == "pval_with_direction") {
        x_axis_title = "-log10(p-value), signed"
      }
      #ridgeplot_file = file.path(GSEA_results_dir2, paste0 ("Ridgeplot_", contrast, ".png"))
      ridgeplot_file = file.path(GSEA_results_dir2, "Ridgeplot.png")
      ridgeplot_edited (res, x_axis_title = x_axis_title, file = ridgeplot_file)  # showCategory = 20 (default is 30)
      ridgeplot_edited (res, x_axis_title = x_axis_title, file = ridgeplot_file, core_enrichment = F)  
      
      #print ridge plot where ranking method for GSEA used p-values but x-axis on plot is log2FC
      
      if (ranking_method != "fc" & contrast != "any_contrast") {
        ranked_genes_by_fc = ranked_genes[["fc"]][[contrast]]
        x_axis_title = "log2(FC)"
        #ridgeplot_file = file.path(GSEA_results_dir2, paste0 ("Ridgeplot_", contrast, "_show_FC.png"))
        ridgeplot_file = file.path(GSEA_results_dir2, "Ridgeplot_showFC.png")
        ridgeplot_edited (res, x_axis_title = x_axis_title, file = ridgeplot_file, values_for_x_axis = ranked_genes_by_fc)  # showCategory = 20 (default is 30)
        ridgeplot_edited (res, x_axis_title = x_axis_title, file = ridgeplot_file, values_for_x_axis = ranked_genes_by_fc, core_enrichment = F)  
      }
      
      #print ridge plot as above, but with limited x-axis
      
      if (ranking_method != "fc" & contrast != "any_contrast") {
        ranked_genes_by_fc = ranked_genes[["fc"]][[contrast]]
        x_axis_title = "log2(FC)"
        #ridgeplot_file = file.path(GSEA_results_dir2, paste0 ("Ridgeplot_", contrast, "_show_FC.png"))
        ridgeplot_file = file.path(GSEA_results_dir2, "Ridgeplot_showFC_1.png")
        ridgeplot_edited (res, x_axis_title = x_axis_title, file = ridgeplot_file, values_for_x_axis = ranked_genes_by_fc, xlimits = c(-1,1))  # showCategory = 20 (default is 30)
        ridgeplot_edited (res, x_axis_title = x_axis_title, file = ridgeplot_file, values_for_x_axis = ranked_genes_by_fc, core_enrichment = F, xlimits = c(-1,1))  
      }
      
      
    }
    
    # #print heatplot - did not produce nice results
    # #see example result here: https://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html
    # 
    # if (nrow(GSEA_results) > 0) {
    #   heatplot(res, foldChange=ranked_genes_by_fc, showCategory=30)
    # }
    
    #print GSEA plots

    # #specify requested analysis (example) - for testing
    # term_db        = "KEGG"               #KEGG, GO_BP, GO_MF, GO_CC
    # ranking_method = "pval_wo_direction"  #"pval_wo_direction", "pval_with_direction", "fc"
    # contrast       = "M_Reverse.vs.NC"    #for method "pval_wo_direction there is also "any_contrast"
 
    #results dir
    GSEA_plots_dir        = file.path(GSEA_results_dir2, "GSEA_plots") %>% create_dir
    Heatmaps_dir1         = file.path(GSEA_results_dir2, "Heatmaps_core_genes") %>% create_dir
    Heatmaps_dir2         = file.path(GSEA_results_dir2, "Heatmaps_all_genes") %>% create_dir
    Excel_per_pathway_dir = file.path(GSEA_results_dir2, "Excels_core_genes") %>% create_dir
    
    #draw GSEA plots - loop over enriched pathways

    if (length(res$ID)>0) {
      for (pathway_nr in 1:length(res$ID)) {
        pathway_id    = res$ID[pathway_nr]
        pathway_id1   = unlist(stringi::stri_split(str = pathway_id, fixed =":") )[2]
        pathway_title = res$Description[pathway_nr]
        
        #cat(pathway_id1, " ", pathway_title, "\n")
        
        #GSEA plot
        png (filename = file.path(GSEA_plots_dir, paste0(pathway_id1, ".png")))
        plot = gseaplot2(res, geneSetID = pathway_nr, title = pathway_title) #the geneSetID argument can also be pathway ID, e.g. "path:mmu04714"
        print(plot)
        dev.off()
        
        #Heatmap core genes
        
        #get leading edge genes
        leading_edge_genes = res$core_enrichment[pathway_nr] %>% stringi::stri_split(regex = "/") %>% unlist
        genes_in_pathway = res@geneSets[res$ID[pathway_nr]]
        #get norm_log_counts counts
        mat2plot_le = filter_expression_matrix_by_gene_list (norm_log_counts, leading_edge_genes)
        #construct graph title
        nr_genes = length(leading_edge_genes)
        title = paste0("Leading edge genes in ", pathway_title, " (n=", nr_genes, ")")
        #plot_heatmap
        file_name = file.path(Heatmaps_dir1, paste0(pathway_id1, ".png"))
        pheatmap_data_core_genes = plot_expression_heatmap(mat2plot_le, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title)
        
        #Heatmap all genes
        
        #get leading edge genes
        genes_in_pathway = res@geneSets[res$ID[pathway_nr]] %>% unlist
        #get norm_log_counts counts
        mat2plot_p = filter_expression_matrix_by_gene_list (norm_log_counts, genes_in_pathway)
        #construct graph title
        nr_genes = length(genes_in_pathway)
        title = paste0("All genes in ", pathway_title, " (n=", nr_genes, ")")
        #plot_heatmap
        file_name = file.path(Heatmaps_dir2, paste0(pathway_id1, ".png"))
        pheatmap_data_all_genes = plot_expression_heatmap(mat2plot_p, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title)
        
        #Gene details (leading edge genes) per pathway in Excel
        
        orig_genes = row.names(mat2plot_le)
        ordered_genes = orig_genes[pheatmap_data_core_genes$tree_row$order]  #order genes by hierarchical clustering order
        res_df2write_DE <- res_df2write[ordered_genes,] %>% select (-starts_with ("manual_cutoffs"))  #add expression and statistics data
        # Add manual cluster
        clustering_result = man_clusters_opt1_ordered                      #specify clustering object (named vector)
        clustering_result = gene_lists[["manual_clustering"]][["FC1.2"]]   #or choose from gene_lists
        man_clusters_df = make_data_frame_from_clusters(clustering_result) %>% setNames(c("gene", "manual_cluster"))
        res_df2write_DE1 = left_join(x=res_df2write_DE, y=man_clusters_df, by="gene")
        # Add Z-score data
        zscore <- z_score(norm_log_counts)
        colnames(zscore) <- zscore %>% colnames %>% paste0(.,".zscore")
        zscore <- zscore %>% as_tibble(rownames = "gene") 
        res_df2write_DE2 = left_join(x=res_df2write_DE1, y=zscore, by="gene")
        #print table
        file_name_csv = file.path (Excel_per_pathway_dir, paste0(pathway_id1, ".csv"))
        write.csv(res_df2write_DE2, file_name_csv, na="")
      } 
      
    }

  }
}
```

## GSEA - GO

```{r GO enrichmentl GSEA}

#run GSEA
#NOTE - this may take a very long time

for (GO_type in c('BP', 'MF', 'CC')){   #c('BP', 'MF', 'CC') or part of it
  GO_type_title = paste0("GO", "_", GO_type)
  cat (GO_type_title, "\n")
  GO2gene = GO_data[[GO_type]][["GO2gene"]]
  GO2name = GO_data[[GO_type]][["GO2name"]]
  GSEA_results_dir  = file.path(GSEA_results_main_dir, GO_type_title) %>% create_dir
  for (ranking_method in names(ranked_genes)) {
    cat (ranking_method, "\n")
    for (contrast in names(ranked_genes[[ranking_method]])) {
      cat (contrast, "\n")
      ranked_genes_to_analyze = ranked_genes[[ranking_method]][[contrast]]
      
      nr_total_genes = length(unique(GO2gene[,2]))  #no. of genes having assigned GO
      res=GSEA (
        geneList      = ranked_genes_to_analyze,
        TERM2GENE     = GO2gene, 
        TERM2NAME     = GO2name,
        minGSSize     = 4,
        maxGSSize     = nr_total_genes,
        pAdjustMethod = ENRICHMENT_PADJ_METHOD,
        pvalueCutoff  = ENRICHMENT_PVAL_CUTOFF)
      
      #store for RShiny
      GSEA_enrichment_results[[GO_type_title]][[ranking_method]][[contrast]] = res
      
      #print results
      GSEA_results = data.frame(res)
      GSEA_results_dir1 = file.path(GSEA_results_dir, paste0("ranking_by_", ranking_method)) %>% create_dir
      GSEA_results_file = file.path(GSEA_results_dir1, paste0 ("GSEA_results_", contrast, ".csv"))
      write.csv(GSEA_results, file=GSEA_results_file, row.names = F)
    }
  }
}
```

## OPTIONAL: Explore a specific pathway

```{r specific pathway}

#View all performed analyses
for (term_db in names(GSEA_enrichment_results)) {
  cat (term_db, "\n")
  for (ranking_method in names(GSEA_enrichment_results[[term_db]])) {
    cat ("  ", ranking_method, "\n")
    for (contrast in names(GSEA_enrichment_results[[term_db]][[ranking_method]])) {
      cat ("    ", contrast, "\n")
    }
  }
}

#specify requested analysis (example)
term_db        = "KEGG"               #KEGG, GO_BP, GO_MF, GO_CC
ranking_method = "pval_wo_direction"  #"pval_wo_direction", "pval_with_direction", "fc"
contrast       = "R.vs.L"             #for method "pval_wo_direction there is also "any_contrast"

#results directory
pathway_results_dir = file.path (GSEA_results_main_dir, "KEGG", "specific_pathways") %>% create_dir
pathway_results_dir1 = file.path (pathway_results_dir, paste0(contrast, "_", ranking_method)) %>% create_dir
  
#get enrichment results
res = GSEA_enrichment_results[[term_db]][[ranking_method]][[contrast]]

#specify requested pathway or GO term
pathway_nr = which(res$ID == "path:mmu05208") #by pathway/GO ID
pathway_nr  = 2                               #or provide the order in the GSEA results directly

#pathway info and create results directory
pathway_id  = res$ID[pathway_nr]
if (term_db == "KEGG") {
  pathway_id1 = unlist(stringi::stri_split(str = pathway_id, fixed =":") )[2]  #remove "path:" from pathway id
} else {
  pathway_id1 = pathway_id
}
pathway_title = res$Description[pathway_nr]
cat (paste0 ("Pathway no. ", pathway_nr, " "), pathway_id, " ", pathway_title, "\n")

#Plot GSEA graph of a specific pathway
gseaplot2(res, geneSetID = pathway_nr, title = pathway_title) #the geneSetID argument can also be pathway ID, e.g. "path:mmu04714"

#another option to draw a similar graph:
gseaplot(res, geneSetID = pathway_nr, by = "runningScore", title = pathway_title)

#draw a heatmap of leading edge genes

#get leading edge genes
leading_edge_genes = res$core_enrichment[pathway_nr] %>% stringi::stri_split(regex = "/") %>% unlist
#get norm_log_counts counts
mat2plot_le = filter_expression_matrix_by_gene_list (norm_log_counts, leading_edge_genes)
#construct graph title
nr_genes = length(leading_edge_genes)
title = paste0("Leading edge genes in ", pathway_title, " (n=", nr_genes, ")")
#plot_heatmap
#file_name = file.path (pathway_results_dir1, paste0(pathway_id1, "_GSEA_LE_genes_heatmap.png"))
file_name = file.path (pathway_results_dir1, paste0(pathway_id1, "_LE_genes_heatmap.png"))
pheatmap_data_gene_list = plot_expression_heatmap(mat2plot_le, EFFECTS, stats_df, col_data, file_name, color_range="red2blue", plot_title=title)

#create gene info table for printing

orig_genes = row.names(mat2plot_le)
ordered_genes = orig_genes[pheatmap_data_gene_list$tree_row$order]  #order genes by hierarchical clustering order
res_df2write_DE <- res_df2write[ordered_genes,] %>% select (-starts_with ("manual_cutoffs"))  #add expression and statistics data
# Add manual cluster
clustering_result = man_clusters_opt1_ordered                      #specify clustering object (named vector)
clustering_result = gene_lists[["manual_clustering"]][["FC1.2"]]   #or choose from gene_lists
man_clusters_df = make_data_frame_from_clusters(clustering_result) %>% setNames(c("gene", "manual_cluster"))
res_df2write_DE1 = left_join(x=res_df2write_DE, y=man_clusters_df, by="gene")
# Add Z-score data
zscore <- z_score(norm_log_counts)
colnames(zscore) <- zscore %>% colnames %>% paste0(.,".zscore")
zscore <- zscore %>% as_tibble(rownames = "gene") 
res_df2write_DE2 = left_join(x=res_df2write_DE1, y=zscore, by="gene")
#print table
#file_name_csv = file.path (pathway_results_dir1, paste0(pathway_id1, "_GSEA_LE_genes.csv"))
file_name_csv = file.path (pathway_results_dir1, paste0(pathway_id1, "_LE_genes.csv"))
write.csv(res_df2write_DE2, file_name_csv, na="")

```

# Prepare data for GUIs

## For SQL import

```{r data2mysql}

file_for_SQL = file.path(results_dir, "norm_counts_for_MySQL.txt")

norm_counts %>% 
    as_tibble(rownames = NA) %>% 
    rownames_to_column( var = "gene") %>% 
    gather(key=sample,value=norm_counts,-gene) %>% 
    # full_join(col_data[,c("SampleID","Day","Sex")],by=c("sample"="SampleID")) %>% 
    full_join(col_data,by=c("sample"="SampleID")) %>% 
    write_delim(file_for_SQL, delim="\t")

```
## For RShiny

```{r data4RShiny}

r_objects_file = file.path(results_dir, "Analysis_Objects.RData")
mat2plot = filter_expression_matrix_by_gene_list (norm_log_counts, top_DE_genes)

#remove "manual_cutoffs" columns from stats_df
stats_df_orig = stats_df
stats_df = select(stats_df, -starts_with("manual_cutoffs"))

#arrange cutoffs and parameters in one list
cutoffs = list(LINEAR_FC_CUTOFF=LINEAR_FC_CUTOFF, PADJ_CUTOFF=PADJ_CUTOFF, CORR_CUTOFF=CORR_CUTOFF, COUNTS_CUTOFF=COUNTS_CUTOFF, ENRICHMENT_PVAL_CUTOFF=ENRICHMENT_PVAL_CUTOFF, ENRICHMENT_PADJ_METHOD=ENRICHMENT_PADJ_METHOD, EFFECT1=EFFECTS[1], EFFECT2=EFFECTS[2], GROUP=GROUP, GROUP1=GROUP1)

#store
if (exists("trinotate_main")) {
  #get all trinotate data from trinotate file
  trinotate <- read.delim(file = trinotate_file)
  #store
  save(analysis_name, cutoffs, trinotate, col_data, contrasts_data, norm_counts, norm_log_counts, stats_df, DE_genes, DE_genes_stats, mat2plot, corrs2, binary_patterns_stats, gene_lists, clusters, Pathway2name, Pathway2gene, enrichment_results, enrichment_table, GSEA_enrichment_results, file=r_objects_file)
} else if (exists("annot")) {
  save(analysis_name, cutoffs, annot,     col_data, contrasts_data, norm_counts, norm_log_counts, stats_df, DE_genes, DE_genes_stats, mat2plot, corrs2, binary_patterns_stats, gene_lists, clusters, Pathway2name, Pathway2gene, enrichment_results, enrichment_table, GSEA_enrichment_results, file=r_objects_file)
}

```

# Session info
```{r session_info}
sessionInfo()
```

